#pragma kernel Cube
#include "./PerlinTable.compute"

static const int numThreads = 8;

static const float dotsScale = 0.05f;
static const float dotsSep = 0.5f;

struct Square {
    float3 a, b, c, d;

    void set(float3 pos) {
        a = b = c = d = pos;
    }
};

AppendStructuredBuffer<Square> squares;

int size;
float3 transition;

float lerp(float a, float b, float x) {
    return a + x * (b - a);
}

// https://en.wikipedia.org/wiki/Smoothstep#Variations
float fade(float t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}

// http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html
float grad(int hash, float x, float y, float z) {
    switch(hash & 0xF) {
        case 0x0: return  x + y;
        case 0x1: return -x + y;
        case 0x2: return  x - y;
        case 0x3: return -x - y;
        case 0x4: return  x + z;
        case 0x5: return -x + z;
        case 0x6: return  x - z;
        case 0x7: return -x - z;
        case 0x8: return  y + z;
        case 0x9: return -y + z;
        case 0xA: return  y - z;
        case 0xB: return -y - z;
        case 0xC: return  y + x;
        case 0xD: return -y + z;
        case 0xE: return  y - x;
        case 0xF: return -y - z;
        default: return 0; // never happens
    }
}

int perlinDot(float3 pos) {
    int xi = (int)pos.x & 255;
    int yi = (int)pos.y & 255;
    int zi = (int)pos.z & 255;

    int verts[8] = {
        permutation[permutation[permutation[xi] + yi] + zi],
        permutation[permutation[permutation[xi + 1] + yi] + zi],
        permutation[permutation[permutation[xi] + yi + 1] + zi],
        permutation[permutation[permutation[xi + 1] + yi + 1] + zi],
        permutation[permutation[permutation[xi] + yi] + zi + 1],
        permutation[permutation[permutation[xi + 1] + yi] + zi + 1],
        permutation[permutation[permutation[xi] + yi + 1] + zi + 1],
        permutation[permutation[permutation[xi + 1] + yi + 1] + zi + 1]
    };
    
    float xd = pos.x - (int)pos.x;
    float yd = pos.y - (int)pos.y;
    float zd = pos.z - (int)pos.z;
    float xf = fade(xd);
    float yf = fade(yd);
    float zf = fade(zd);

    float value = lerp(
        lerp(
            lerp(
                grad(verts[0], xd, yd, zd),
                grad(verts[1], xd - 1, yd, zd),
                xf
            ), 
            lerp(
                grad(verts[2], xd, yd - 1, zd),
                grad(verts[3], xd - 1, yd - 1, zd),
                xf
            ),
            yf
        ),
        lerp(
            lerp(
                grad(verts[4], xd, yd, zd - 1),
                grad(verts[5], xd - 1, yd, zd - 1),
                xf
            ),
            lerp(
                grad(verts[6], xd, yd - 1, zd - 1),
                grad(verts[7], xd - 1, yd - 1, zd - 1),
                xf
            ),
            yf
        ),
        zf
    );

    return ((value + 1) / 2 < dotsSep) ? 0 : 1;
}

[numthreads(numThreads, numThreads, numThreads)]
void Cube(int3 id : SV_DispatchThreadID) {
    if (id.x >= size || id.y >= size || id.z >= size)
        return;

    float3 center = float3(
        (float)id.x + transition.x + 0.5,
        (float)id.y + transition.y + 0.5,
        (float)id.z + transition.z + 0.5
    );
    int4 perlin = int4(
        perlinDot((center + float3(1, 0, 0)) * dotsScale),
        perlinDot((center + float3(0, 1, 0)) * dotsScale),
        perlinDot((center + float3(0, 0, 1)) * dotsScale),
        perlinDot(center * dotsScale)
    );

    Square sq;
    if (perlin.w != perlin.x) {
        sq.set(id + transition);
        if (perlin.x == 0) {
            sq.a += float3(1, 1, 0);
            sq.b += float3(1, 1, 1);
            sq.c += float3(1, 0, 1);
            sq.d += float3(1, 0, 0);
        } else {
            sq.a += float3(1, 0, 0);
            sq.b += float3(1, 0, 1);
            sq.c += float3(1, 1, 1);
            sq.d += float3(1, 1, 0);
        }
        squares.Append(sq);
    }
    if (perlin.w != perlin.y) {
        sq.set(id + transition);
        if (perlin.y == 0) {
            sq.a += float3(0, 1, 0);
            sq.b += float3(0, 1, 1);
            sq.c += float3(1, 1, 1);
            sq.d += float3(1, 1, 0);
        } else {
            sq.a += float3(1, 1, 0);
            sq.b += float3(1, 1, 1);
            sq.c += float3(0, 1, 1);
            sq.d += float3(0, 1, 0);
        }
        squares.Append(sq);
    }
    if (perlin.w != perlin.z) {
        sq.set(id + transition);
        if (perlin.z == 0) {
            sq.a += float3(1, 1, 1);
            sq.b += float3(0, 1, 1);
            sq.c += float3(0, 0, 1);
            sq.d += float3(1, 0, 1);
        } else {
            sq.a += float3(1, 0, 1);
            sq.b += float3(0, 0, 1);
            sq.c += float3(0, 1, 1);
            sq.d += float3(1, 1, 1);
        }
        squares.Append(sq);
    }
}
