#pragma kernel CSPerlin

static float dotsScale = 0.22f;
static float dotsSep = 0.48f;

RWStructuredBuffer<int> dots;
StructuredBuffer<int> perm;

uint size;
float4 trans;

float lerp(float a, float b, float x) {
    return a + x * (b - a);
}

// https://en.wikipedia.org/wiki/Smoothstep#Variations
float fade(float t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}

// http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html
float grad(int hash, float x, float y, float z) {
    switch(hash & 0xF) {
        case 0x0: return  x + y;
        case 0x1: return -x + y;
        case 0x2: return  x - y;
        case 0x3: return -x - y;
        case 0x4: return  x + z;
        case 0x5: return -x + z;
        case 0x6: return  x - z;
        case 0x7: return -x - z;
        case 0x8: return  y + z;
        case 0x9: return -y + z;
        case 0xA: return  y - z;
        case 0xB: return -y - z;
        case 0xC: return  y + x;
        case 0xD: return -y + z;
        case 0xE: return  y - x;
        case 0xF: return -y - z;
        default: return 0; // never happens
    }
}

[numthreads(8, 8, 1)]
void CSPerlin (uint3 id : SV_DispatchThreadID) {
    if (id.x >= size || id.y >= size || id.z >= size)
        return;

    float x = (((float)id.x - 0.5) + trans.x) * dotsScale;
    float y = (((float)id.y - 0.5) + trans.y) * dotsScale;
    float z = (((float)id.z - 0.5) + trans.z) * dotsScale;

    int xi = (int)x & 255;
    int yi = (int)y & 255;
    int zi = (int)z & 255;

    int verts[8] = {
        perm[perm[perm[xi] + yi] + zi],
        perm[perm[perm[xi + 1] + yi] + zi],
        perm[perm[perm[xi] + yi + 1] + zi],
        perm[perm[perm[xi + 1] + yi + 1] + zi],
        perm[perm[perm[xi] + yi] + zi + 1],
        perm[perm[perm[xi + 1] + yi] + zi + 1],
        perm[perm[perm[xi] + yi + 1] + zi + 1],
        perm[perm[perm[xi + 1] + yi + 1] + zi + 1]
    };
    
    float xd = x - (int)x;
    float yd = y - (int)y;
    float zd = z - (int)z;
    float xf = fade(xd);
    float yf = fade(yd);
    float zf = fade(zd);

    float value = lerp(
        lerp(
            lerp(
                grad(verts[0], xd, yd, zd),
                grad(verts[1], xd - 1, yd, zd),
                xf), 
            lerp(
                grad(verts[2], xd, yd - 1, zd),
                grad(verts[3], xd - 1, yd - 1, zd),
                xf),
            yf),
        lerp(
            lerp(
                grad(verts[4], xd, yd, zd - 1),
                grad(verts[5], xd - 1, yd, zd - 1),
                xf),
            lerp(
                grad(verts[6], xd, yd - 1, zd - 1),
                grad(verts[7], xd - 1, yd - 1, zd - 1),
                xf),
            yf),
        zf);

    dots[(id.z * size + id.y) * size + id.x] = ((value + 1) / 2 < dotsSep) ? 0 : 1;
}